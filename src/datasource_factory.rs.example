// Example: Adding a new datasource type (e.g., Redis)

use super::*;

/// Redis datasource factory
pub struct RedisFactory;

#[async_trait]
impl DatasourceFactory for RedisFactory {
    async fn create(
        &self,
        config: &IndexerConfig,
        event_mappings: &[IndexerContractMapping],
    ) -> Result<Box<dyn DatasourceWritable>, IndexerError> {
        // Extract Redis configuration from config
        let redis_conf = config.redis.as_ref()
            .ok_or_else(|| IndexerError::Config("Redis configuration missing".to_string()))?;

        // Initialize Redis client
        let client = crate::redis::init_redis_db(redis_conf, event_mappings)
            .await
            .map_err(|e| IndexerError::Config(format!("Failed to initialize Redis: {:?}", e)))?;

        Ok(Box::new(client))
    }

    fn can_handle(&self, config: &IndexerConfig) -> bool {
        config.redis.is_some()
    }

    fn name(&self) -> &'static str {
        "redis"
    }
}

// To register the new datasource, simply add it to create_default_registry():
// registry.register(Box::new(RedisFactory));

// No other code changes needed! The factory pattern handles everything else.
